package dao;

import com.mysql.cj.jdbc.JdbcConnection;
import controller.LoginController;
import dao.helper.JDBC;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import model.Customer;
import model.Division;
import model.ReportByDivision;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.time.ZoneOffset;

/**
 * This class is part of the data access layer. It allows access and to query the customers table in the db.
 */

public class CustomerDao {
    /**
     * Simple select query to retrieve all customers from the table.
     * @return ObservableList of Customer objects
     * @throws SQLException
     */
    public static ObservableList<Customer> getAllCustomers() throws SQLException {
        // getting divisions first to get all division names
        ObservableList<Division> divisions = DivisionDao.getAllDivisions();

        // getting all customers
        String query = "Select * from customers;";
        PreparedStatement ps = JDBC.connection.prepareStatement(query);
        ResultSet rs = ps.executeQuery();

        ObservableList<Customer> customers = FXCollections.observableArrayList();
        while(rs.next()){
            long customerId = rs.getLong("Customer_ID");
            String name = rs.getString("Customer_Name");
            String address = rs.getString("Address");
            String postalCode = rs.getString("Postal_Code");
            String phone = rs.getString("Phone");
            long divisionId = rs.getLong("Division_ID");
            String divisionName = "";
            // setting division names in customer objects to simplify later processes.
            // retrieving division name from list of divisions by match divisionId
            // this should be optimized with a hashmap
            for(Division division: divisions) {
                if(division.getDivisionId()==divisionId) {
                    divisionName = division.getDivision();
                    break;
                }
            }

            // creating the object and adding it to the list
            Customer newCustomer = new Customer(customerId, name, address, postalCode, phone, divisionId, divisionName);
            customers.add(newCustomer);
        }
        return customers;
    }

    /**
     * Search tool to retrieve a customer using the provided id number.
     * @param customerId long variable containing the id to match against.
     * @return Customer object containing the match.
     * @throws SQLException
     */
    public static Customer getCustomerById(long customerId) throws SQLException {
        // getting divisions first to get all division names
        ObservableList<Division> divisions = DivisionDao.getAllDivisions();

        String query = "Select * from customers where Customer_ID=?;";

        PreparedStatement ps = JDBC.connection.prepareStatement(query);
        ps.setLong(1, customerId);
        ResultSet rs = ps.executeQuery();

        // retrieving the single customer info from the columns
        String name="", address="", postalCode="", phone="", divisionName="";
        long divisionId=-1;
        while(rs.next()){
            name = rs.getString("Customer_Name");
            address = rs.getString("Address");
            postalCode = rs.getString("Postal_Code");
            phone = rs.getString("Phone");
            divisionId = rs.getLong("Division_ID");
            divisionName = "";
            // retrieving division name from list of divisions by match divisionId
            // this should be optimized with a hashmap
            for(Division division: divisions) {
                if(division.getDivisionId()==divisionId) {
                    divisionName = division.getDivision();
                    break;
                }
            }
        }
        // initiazing the object with the retrieved info
        Customer customer = new Customer(customerId, name, address, postalCode, phone, divisionId, divisionName);
        return customer;
    }

    /**
     * Add a new customer using the information provided in the object passed as argument.
     * The ID is automatically generated by the db.
     * @param newCustomer object containing the customer data to push to db
     * @throws SQLException
     */
    public static void addCustomer(Customer newCustomer) throws SQLException {
        String query = "INSERT INTO customers(Customer_Name, Address, Postal_Code, Phone, Create_Date, Created_By, Last_Update, Last_Updated_By, Division_ID) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
        PreparedStatement ps = JDBC.connection.prepareStatement(query);
        ps.setString(1, newCustomer.getCustomerName());
        ps.setString(2, newCustomer.getAddress());
        ps.setString(3, newCustomer.getPostalCode());
        ps.setString(4, newCustomer.getPhone());
        ps.setTimestamp(5, Timestamp.valueOf(LocalDateTime.now(ZoneOffset.UTC)));
        ps.setString(6, LoginController.userLoggedIn.getUserName());
        ps.setTimestamp(7, Timestamp.valueOf(LocalDateTime.now(ZoneOffset.UTC)));
        ps.setString(8, LoginController.userLoggedIn.getUserName());
        ps.setLong(9, newCustomer.getDivisionId());

        // executing insertion, no return expected
        ps.execute();
    }

    /**
     * Updates an existing customer using the data passed in the object.
     * @param customer object with updated info for the customer.
     * @throws SQLException
     */
    public static void updateCustomer(Customer customer) throws SQLException {
        String query = "UPDATE customers set Customer_Name=?, Address=?, Postal_Code=?, Phone=?, Last_Update=?, Last_Updated_By=?, Division_ID=? WHERE Customer_ID=?;";
        PreparedStatement ps = JDBC.connection.prepareStatement(query);

        // inserting query parameters
        ps.setString(1, customer.getCustomerName());
        ps.setString(2, customer.getAddress());
        ps.setString(3, customer.getPostalCode());
        ps.setString(4, customer.getPhone());
        ps.setTimestamp(5, Timestamp.valueOf(LocalDateTime.now()));
        ps.setString(6, LoginController.userLoggedIn.getUserName());
        ps.setLong(7, customer.getDivisionId());
        ps.setLong(8, customer.getCustomerId());

        // executing without expecting returns
        ps.execute();
    }

    /**
     * First Deletes any appointments associated with provided customer id.
     * Then deletes the customer from the customers table using the provided id.
     * @param customerId long variable containing the customer id
     * @throws SQLException
     */
    public static void deleteCustomer(long customerId) throws SQLException {
        String query1 = "DELETE FROM appointments where Customer_ID=?";
        PreparedStatement ps1 = JDBC.connection.prepareStatement(query1);
        ps1.setLong(1, customerId);
        ps1.execute();

        String query2 = "DELETE FROM customers WHERE Customer_ID=?;";
        PreparedStatement ps2 = JDBC.connection.prepareStatement(query2);
        ps2.setLong(1, customerId);
        ps2.execute();
    }

    /**
     * Retrieves a report from customers table to display number of customers in each division.
     * @return ObservableList of ReportByDivision objects
     * @throws SQLException
     */
    public static ObservableList<ReportByDivision> getReportByDivision() throws SQLException {
        // getting divisions first to get all division names
        ObservableList<Division> divisions = DivisionDao.getAllDivisions();

        // a list to store each row in
        ObservableList<ReportByDivision> reports = FXCollections.observableArrayList();

        // retrieving resulting data with division_id, will get division names using the id
        String query = "Select Division_ID, count(*) from customers group by Division_ID;";
        PreparedStatement ps = JDBC.connection.prepareStatement(query);
        ResultSet rs = ps.executeQuery();

        while(rs.next()) {
            String name = "";
            long divisionId = rs.getLong("Division_ID");
            // getting division name from list of divisions
            for(Division division: divisions) {
                if(division.getDivisionId()==divisionId) {
                    name = division.getDivision();
                    break;
                }
            }

            long total = rs.getLong("count(*)");
            // Initializing report data into an object and adding object to a list
            ReportByDivision report = new ReportByDivision(name, total);
            reports.add(report);
        }

        return reports;
    }
}
